#!/usr/bin/env node
import program, { Command } from 'commander';
import fs from 'fs';
import path from 'path';
import { interval } from 'rxjs';
import { first, map, timeout } from 'rxjs/operators';
import { StringDecoder } from 'string_decoder';
import util from 'util';
import { v4 } from 'uuid';
import YAML from 'yaml';
import zmq from 'zeromq';

import {
  ComputeAutoTuningGainsType,
  DeviceAddressType,
  MotionMasterClient,
  RequestType,
  SignalGeneratorType,
  StatusType,
} from './motion-master-client';
import { MotionMasterNotification } from './motion-master-notification';
import {
  decodeMotionMasterMessage,
  encodeMotionMasterMessage,
  MotionMasterMessage,
} from './util';

type OutputFormat = 'inspect' | 'json' | 'yaml';

enum ExitStatus {
  SUCCESS,
  UNCAUGHT_EXCEPTION,
  UNHANDLED_REJECTION,
  TIMEOUT,
  INCORRECT_PARAMETER_FORMAT,
}

// tslint:disable: no-var-requires
const debug = require('debug')('motion-master-client');
const version = require('../package.json')['version'];
// tslint:enable-next-line: no-var-requires

process.on('uncaughtException', (err) => {
  console.error('Caught exception: ' + err);
  process.exit(ExitStatus.UNCAUGHT_EXCEPTION);
});

process.on('unhandledRejection', (reason) => {
  console.error('Unhandled rejection reason: ', reason);
  process.exit(ExitStatus.UNHANDLED_REJECTION);
});

const inspectOptions: util.InspectOptions = {
  showHidden: false,
  depth: null,
  colors: true,
  maxArrayLength: null,
  compact: false,
};

// map to cache device parameter info per device
const deviceParameterInfoMap: Map<number, MotionMasterMessage.Status.IDeviceParameterInfo | null | undefined> = new Map();

const motionMasterClient = new MotionMasterClient();
const motionMasterNotification = new MotionMasterNotification();

const config = {
  pingSystemInterval: 150, // ping Motion Master at regular intervals
  motionMasterHeartbeatTimeoutDue: 1000, // exit process when Motion Master doesn't send a heartbeat message in time specified
  serverEndpoint: 'tcp://127.0.0.1:62524', // request and receive status messages (response)
  notificationEndpoint: 'tcp://127.0.0.1:62525', // subscribe to a topic and receive published status messages (heartbeat and monitoring)
  identity: v4(), // ZeroMQ DEALER socket identity
};

//
// program and commands
//

program
  .version(version)
  .option('-c, --config <path>', 'path to JSON config file to read and replace the default values with')
  .option('-d, --device-address <address>', 'device address (uint32) generated by Motion Master - takes precedence over device position', parseOptionValueAsInt)
  .option('-f, --output-format <json|yaml>', 'if left unspecified the output format is the default colored message inspect')
  .option('-p, --device-position <position>', 'used when device address is not specified', parseOptionValueAsInt, 0);

program
  .command('request <type> [args...]')
  .option('-i, --interval <value>', 'sending interval in microseconds', parseOptionValueAsInt, 1 * 1000 * 1000)
  .on('--help', () => {
    const types = Object.keys(MotionMasterMessage.Request).slice(8).map((type) => type.charAt(0).toLowerCase() + type.slice(1));
    console.log('');
    console.log('Request <type>s:');
    console.log('  ' + types.join('\n  '));
  })
  .action(requestAction);

program
  .command('upload [params...]')
  .option('-s, --send-progress')
  .action(uploadAction);

program
  .command('download [paramValues...]')
  .action(downloadAction);

program
  .command('getDeviceFileContent <filename>')
  .action(getDeviceFileContentAction);

program
  .command('getDeviceLogContent')
  .action(getDeviceLogContentAction);

program
  .command('getCoggingTorqueDataContent')
  .action(getCoggingTorqueDataContent);

program
  .command('startCoggingTorqueRecording')
  .option('-s, --skip-auto-tuning')
  .action(startCoggingTorqueRecordingAction);

program
  .command('startOffsetDetection')
  .action(startOffsetDetectionAction);

program
  .command('startPlantIdentification <durationSeconds> <torqueAmplitude> <startFrequency> <endFrequency> <cutoffFrequency>')
  .action(startPlantIdentificationAction);

program
  .command('startSystemIdentification <durationSeconds> <torqueAmplitude> <startFrequency> <endFrequency>')
  .action(startSystemIdentificationAction);

program
  .command('startCirculoEncoderNarrowAngleCalibrationProcedure <encoderPort>')
  .action(startCirculoEncoderNarrowAngleCalibrationProcedureAction);

program
  .command('monitor <topic> [params...]')
  .option('-i, --interval <value>', 'sending interval in microseconds', parseOptionValueAsInt, 1 * 1000 * 1000)
  .action(monitorAction);

// parse command line arguments and execute the command action
program.parse(process.argv);

//
// command action functions
//

async function requestAction(type: RequestType, args: string[], cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);

  switch (type) {
    case 'pingSystem': {
      motionMasterClient.requestPingSystem(messageId);

      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'getSystemVersion': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetSystemVersion(messageId);

      break;
    }
    case 'getDeviceInfo': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetDeviceInfo(messageId);

      break;
    }
    case 'getDeviceParameterInfo': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetDeviceParameterInfo(deviceAddress, messageId);

      break;
    }
    case 'getDeviceParameterValues': {
      exitOnMessageReceived(messageId);

      const parameters: MotionMasterMessage.Request.GetDeviceParameterValues.IParameter[] = args.map(paramToIndexSubindex);
      validateParameters(parameters);
      motionMasterClient.requestGetDeviceParameterValues(deviceAddress, parameters, false, messageId);

      break;
    }
    case 'getMultiDeviceParameterValues': {
      throw new Error(`Request "${type}" is not yet implemented`);
    }
    case 'setDeviceParameterValues': {
      exitOnMessageReceived(messageId);

      const deviceParameterInfo = await getDeviceParameterInfoAsync(deviceAddress);
      const parameterValues = args.map((paramValue) => paramToIndexSubIndexValue(paramValue, deviceParameterInfo));
      motionMasterClient.requestSetDeviceParameterValues(deviceAddress, parameterValues, messageId);

      break;
    }
    case 'setMultiDeviceParameterValues': {
      throw new Error(`Request "${type}" is not yet implemented`);
    }
    case 'getDeviceFileList': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetDeviceFileList(deviceAddress, messageId);

      break;
    }
    case 'getDeviceFile': {
      exitOnMessageReceived(messageId);

      const name = args[0];
      motionMasterClient.requestGetDeviceFile(deviceAddress, name, messageId);

      break;
    }
    case 'setDeviceFile': {
      exitOnMessageReceived(messageId);

      const filepath = args[0];
      const name = path.basename(filepath);
      const content = fs.readFileSync(filepath);
      const overwrite = true;
      motionMasterClient.requestSetDeviceFile(deviceAddress, name, content, overwrite, messageId);

      break;
    }
    case 'deleteDeviceFile': {
      exitOnMessageReceived(messageId);

      const name = args[0];
      motionMasterClient.requestDeleteDeviceFile(deviceAddress, name, messageId);

      break;
    }
    case 'resetDeviceFault': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestResetDeviceFault(deviceAddress, messageId);

      break;
    }
    case 'stopDevice': {
      motionMasterClient.requestStopDevice(deviceAddress, messageId);

      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'startDeviceFirmwareInstallation': {
      exitOnMessageReceived(messageId, 120000, MotionMasterMessage.Status.DeviceFirmwareInstallation.Success.Code.DONE);

      const filepath = args[0];
      const firmwarePackageContent = fs.readFileSync(filepath);

      motionMasterClient.requestStartDeviceFirmwareInstallation(deviceAddress, firmwarePackageContent, messageId);

      break;
    }
    case 'getDeviceLog': {
      exitOnMessageReceived(messageId);

      const getDeviceLog: MotionMasterMessage.Request.IGetDeviceLog = { deviceAddress };

      motionMasterClient.sendRequest({ getDeviceLog }, messageId);
      break;
    }
    case 'startCoggingTorqueRecording': {
      exitOnMessageReceived(messageId, 300000, MotionMasterMessage.Status.CoggingTorqueRecording.Success.Code.DONE);

      const skipAutoTuning = parseInt(args[0], 10) !== 0;

      motionMasterClient.requestStartCoggingTorqueRecording(deviceAddress, skipAutoTuning, messageId);

      break;
    }
    case 'getCoggingTorqueData': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetCoggingTorqueData(deviceAddress, messageId);

      break;
    }
    case 'startOffsetDetection': {
      exitOnMessageReceived(messageId, 180000, MotionMasterMessage.Status.OffsetDetection.Success.Code.DONE);

      motionMasterClient.requestStartOffsetDetection(deviceAddress, messageId);

      break;
    }
    case 'startPlantIdentification': {
      exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.PlantIdentification.Success.Code.DONE);

      const durationSeconds = parseFloat(args[0]);
      const torqueAmplitude = parseInt(args[1], 10);
      const startFrequency = parseInt(args[2], 10);
      const endFrequency = parseInt(args[3], 10);
      const cutoffFrequency = parseInt(args[4], 10);

      motionMasterClient.requestStartPlantIdentification(deviceAddress, durationSeconds, torqueAmplitude, startFrequency, endFrequency, cutoffFrequency, messageId);

      break;
    }
    case 'startSystemIdentification': {
      exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.SystemIdentification.Success.Code.DONE);

      const durationSeconds = parseFloat(args[0]);
      const torqueAmplitude = parseInt(args[1], 10);
      const startFrequency = parseFloat(args[2]);
      const endFrequency = parseFloat(args[3]);

      motionMasterClient.requestStartSystemIdentification(deviceAddress, durationSeconds, torqueAmplitude, startFrequency, endFrequency, messageId);

      break;
    }
    case 'computeAutoTuningGains': {
      const computeAutoTuningGainsType = args[0] as ComputeAutoTuningGainsType;
      switch (computeAutoTuningGainsType) {
        case 'positionParameters': {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.AutoTuning.Success.Code.POSITION_DONE);

          const controllerType = parseInt(args[1], 10);
          const settlingTime = parseFloat(args[2]);
          const positionDamping = parseFloat(args[3]);
          const alphaMult = parseInt(args[4], 10);
          const order = parseInt(args[5], 10);
          const lb = parseFloat(args[6]);
          const ub = parseFloat(args[7]);

          const computeAutoTuningGains: MotionMasterMessage.Request.IComputeAutoTuningGains = {
            deviceAddress,
            positionParameters: {
              controllerType,
              settlingTime,
              positionDamping,
              alphaMult,
              order,
              lb,
              ub,
            },
          };

          motionMasterClient.sendRequest({ computeAutoTuningGains }, messageId);
          break;
        }
        case 'velocityParameters': {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.AutoTuning.Success.Code.VELOCITY_DONE);

          const velocityLoopBandwidth = parseFloat(args[1]);
          const velocityDamping = parseFloat(args[2]);

          const computeAutoTuningGains: MotionMasterMessage.Request.IComputeAutoTuningGains = {
            deviceAddress,
            velocityParameters: {
              velocityLoopBandwidth,
              velocityDamping,
            },
          };

          motionMasterClient.sendRequest({ computeAutoTuningGains }, messageId);
          break;
        }
        default: {
          throw new Error(`Unknown compute auto-tuning gains type: ${computeAutoTuningGainsType}`);
        }
      }
      break;
    }
    case 'setMotionControllerParameters': {
      const target = parseInt(args[0], 10);

      const setMotionControllerParameters: MotionMasterMessage.Request.ISetMotionControllerParameters = {
        deviceAddress,
        target,
      };

      motionMasterClient.sendRequest({ setMotionControllerParameters }, messageId);
      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'enableMotionController': {
      exitOnMessageReceived(messageId);

      const controllerType = parseInt(args[0], 10);
      const filter = parseInt(args[1], 10) !== 0;

      motionMasterClient.requestEnableMotionController(deviceAddress, controllerType, filter, messageId);

      break;
    }
    case 'disableMotionController': {
      motionMasterClient.requestDisableMotionController(deviceAddress, messageId);
      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'setSignalGeneratorParameters': {
      const signalGeneratorType = args[0] as SignalGeneratorType;

      const setSignalGeneratorParameters: MotionMasterMessage.Request.ISetSignalGeneratorParameters = { deviceAddress };

      switch (signalGeneratorType) {
        case 'positionStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);

          setSignalGeneratorParameters.positionStepResponse = {
            target,
            sustainTime,
          };
          break;
        }
        case 'positionAdvancedStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.positionAdvancedStepResponse = {
            target,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'positionRamp': {
          const target = parseInt(args[1], 10);
          const profileVelocity = parseInt(args[2], 10);
          const profileAcceleration = parseInt(args[3], 10);
          const profileDeceleration = parseInt(args[4], 10);
          const sustainTime = parseInt(args[5], 10);

          setSignalGeneratorParameters.positionRamp = {
            target,
            profileVelocity,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
          };
          break;
        }
        case 'positionTrapezoidal': {
          const target = parseInt(args[1], 10);
          const profileVelocity = parseInt(args[2], 10);
          const profileAcceleration = parseInt(args[3], 10);
          const profileDeceleration = parseInt(args[4], 10);
          const sustainTime = parseInt(args[5], 10);
          const repeat = parseInt(args[6], 10) !== 0;

          setSignalGeneratorParameters.positionTrapezoidal = {
            target,
            profileVelocity,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'positionBidirectional': {
          const target = parseInt(args[1], 10);
          const profileVelocity = parseInt(args[2], 10);
          const profileAcceleration = parseInt(args[3], 10);
          const profileDeceleration = parseInt(args[4], 10);
          const sustainTime = parseInt(args[5], 10);
          const repeat = parseInt(args[6], 10) !== 0;

          setSignalGeneratorParameters.positionBidirectional = {
            target,
            profileVelocity,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'positionSineWave': {
          const amplitude = parseInt(args[1], 10);
          const frequency = parseFloat(args[2]);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.positionSineWave = {
            amplitude,
            frequency,
            repeat,
          };
          break;
        }
        case 'velocityStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);

          setSignalGeneratorParameters.velocityStepResponse = {
            target,
            sustainTime,
          };
          break;
        }
        case 'velocityAdvancedStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.velocityAdvancedStepResponse = {
            target,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'velocityRamp': {
          const target = parseInt(args[1], 10);
          const profileAcceleration = parseInt(args[2], 10);
          const profileDeceleration = parseInt(args[3], 10);
          const sustainTime = parseInt(args[4], 10);

          setSignalGeneratorParameters.velocityRamp = {
            target,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
          };
          break;
        }
        case 'velocityTrapezoidal': {
          const target = parseInt(args[1], 10);
          const profileAcceleration = parseInt(args[2], 10);
          const profileDeceleration = parseInt(args[3], 10);
          const sustainTime = parseInt(args[4], 10);
          const repeat = parseInt(args[5], 10) !== 0;

          setSignalGeneratorParameters.velocityTrapezoidal = {
            target,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'velocityBidirectional': {
          const target = parseInt(args[1], 10);
          const profileAcceleration = parseInt(args[2], 10);
          const profileDeceleration = parseInt(args[3], 10);
          const sustainTime = parseInt(args[4], 10);
          const repeat = parseInt(args[5], 10) !== 0;

          setSignalGeneratorParameters.velocityBidirectional = {
            target,
            profileAcceleration,
            profileDeceleration,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'velocitySineWave': {
          const amplitude = parseInt(args[1], 10);
          const frequency = parseFloat(args[2]);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.velocitySineWave = {
            amplitude,
            frequency,
            repeat,
          };
          break;
        }
        case 'torqueStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);

          setSignalGeneratorParameters.torqueStepResponse = {
            target,
            sustainTime,
          };
          break;
        }
        case 'torqueAdvancedStepResponse': {
          const target = parseInt(args[1], 10);
          const sustainTime = parseInt(args[2], 10);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.torqueAdvancedStepResponse = {
            target,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'torqueRamp': {
          const target = parseInt(args[1], 10);
          const torqueSlope = parseInt(args[2], 10);
          const sustainTime = parseInt(args[3], 10);

          setSignalGeneratorParameters.torqueRamp = {
            target,
            torqueSlope,
            sustainTime,
          };
          break;
        }
        case 'torqueTrapezoidal': {
          const target = parseInt(args[1], 10);
          const torqueSlope = parseInt(args[2], 10);
          const sustainTime = parseInt(args[3], 10);
          const repeat = parseInt(args[4], 10) !== 0;

          setSignalGeneratorParameters.torqueTrapezoidal = {
            target,
            torqueSlope,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'torqueBidirectional': {
          const target = parseInt(args[1], 10);
          const torqueSlope = parseInt(args[2], 10);
          const sustainTime = parseInt(args[3], 10);
          const repeat = parseInt(args[4], 10) !== 0;

          setSignalGeneratorParameters.torqueBidirectional = {
            target,
            torqueSlope,
            sustainTime,
            repeat,
          };
          break;
        }
        case 'torqueSineWave': {
          const amplitude = parseInt(args[1], 10);
          const frequency = parseFloat(args[2]);
          const repeat = parseInt(args[3], 10) !== 0;

          setSignalGeneratorParameters.torqueSineWave = {
            amplitude,
            frequency,
            repeat,
          };
          break;
        }
        default: {
          throw new Error(`Unknown set signal generator parameters type: ${signalGeneratorType}`);
        }
      }

      motionMasterClient.sendRequest({ setSignalGeneratorParameters }, messageId);
      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'startSignalGenerator': {
      exitOnMessageReceived(messageId, 2147483647, MotionMasterMessage.Status.SignalGenerator.Success.Code.DONE);

      motionMasterClient.requestStartSignalGenerator(deviceAddress, messageId);

      break;
    }
    case 'stopSignalGenerator': {
      motionMasterClient.requestStopSignalGenerator(deviceAddress, messageId);
      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'startMonitoringDeviceParameterValues': {
      const parameters = args.slice(1).map(paramToIndexSubindex) as MotionMasterMessage.Request.GetDeviceParameterValues.IParameter[];
      validateParameters(parameters);
      const getDeviceParameterValues = { deviceAddress, parameters };
      const topic = args[0];

      requestStartMonitoringDeviceParameterValues({ getDeviceParameterValues, interval: cmd.interval, topic });
      break;
    }
    case 'stopMonitoringDeviceParameterValues': {
      const startMonitoringRequestId = args[0];

      motionMasterClient.requestStopMonitoringDeviceParameterValues(startMonitoringRequestId, messageId);

      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'getEthercatNetworkState': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetEthercatNetworkState(deviceAddress, messageId);

      break;
    }
    case 'setEthercatNetworkState': {
      exitOnMessageReceived(messageId);

      const state = parseInt(args[0], 10);
      motionMasterClient.requestSetEthercatNetworkState(deviceAddress, state, messageId);

      break;
    }
    case 'startNarrowAngleCalibration': {
      exitOnMessageReceived(messageId, 180000, MotionMasterMessage.Status.NarrowAngleCalibration.Success.Code.DONE);

      motionMasterClient.requestStartNarrowAngleCalibration(deviceAddress);

      break;
    }
    case 'setSystemClientTimeout': {
      const timeoutMs = parseInt(args[0], 10);
      motionMasterClient.requestSetSystemClientTimeout(timeoutMs, messageId);

      process.exit(ExitStatus.SUCCESS);
      break;
    }
    case 'getCirculoEncoderMagnetDistance': {
      exitOnMessageReceived(messageId);

      const encoderPort = parseInt(args[0], 10);
      motionMasterClient.requestGetCirculoEncoderMagnetDistance(deviceAddress, encoderPort, messageId);

      break;
    }
    case 'startCirculoEncoderNarrowAngleCalibrationProcedure': {
      exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.CirculoEncoderNarrowAngleCalibrationProcedure.Success.Code.DONE);

      const encoderPort = parseInt(args[0], 10);
      motionMasterClient.requestStartCirculoEncoderNarrowAngleCalibrationProcedure(deviceAddress, encoderPort, messageId);

      break;
    }
    case 'getDeviceCia402State': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetDeviceCia402State(deviceAddress, messageId);

      break;
    }
    case 'setDeviceCia402State': {
      exitOnMessageReceived(messageId);

      const state = parseInt(args[0], 10);
      motionMasterClient.requestSetDeviceCia402State(deviceAddress, state, messageId);

      break;
    }
    case 'getSystemLog': {
      exitOnMessageReceived(messageId);

      motionMasterClient.requestGetSystemLog(messageId);

      break;
    }
    case 'startDeviceSiiRestore': {
      exitOnMessageReceived(messageId, 120000, MotionMasterMessage.Status.DeviceSiiRestore.Success.Code.DONE);

      const devicePosition = parseInt(args[0], 10);

      const filepath = args[1];
      const firmwarePackageContent = fs.readFileSync(filepath);

      motionMasterClient.requestStartDeviceSiiRestore(devicePosition, firmwarePackageContent, messageId);

      break;
    }
    case 'startOpenLoopFieldControl': {
      exitOnMessageReceived(messageId, 2147483647, MotionMasterMessage.Status.OpenLoopFieldControl.Success.Code.DONE);

      const properties: MotionMasterMessage.Request.IStartOpenLoopFieldControl = {
        deviceAddress,
        angle: parseInt(args[0], 10),
        velocity: parseInt(args[1], 10),
        acceleration: parseInt(args[2], 10),
        torque: parseInt(args[3], 10),
        torqueSpeed: parseInt(args[4], 10),
      };

      motionMasterClient.requestStartOpenLoopFieldControl(properties, messageId);

      break;
    }
    case 'computeFullAutoTuningGains': {
      const tuningType = parseInt(args[0], 10); // POSITION (0), VELOCITY (1)
      const controllerType = args[1] // UNSPECIFIED (0), PI_P (1), P_PI (2)
        ? parseInt(args[1], 10)
        : MotionMasterMessage.Request.ComputeFullAutoTuningGains.ControllerType.UNSPECIFIED;

      switch (tuningType) {
        case 0: {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.FullAutoTuning.Success.Code.POSITION_DONE);

          motionMasterClient.requestComputeFullAutoTuningGains(deviceAddress, tuningType, controllerType, messageId);

          break;
        }
        case 1: {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.FullAutoTuning.Success.Code.VELOCITY_DONE);

          motionMasterClient.requestComputeFullAutoTuningGains(deviceAddress, tuningType, controllerType, messageId);

          break;
        }
        default: {
          throw new Error(`Unknown compute auto-tuning gains type: ${tuningType}`);
        }
      }
      break;
    }
    case 'startFullAutoTuning': {
      const tuningType = parseInt(args[0], 10); // POSITION (0), VELOCITY (1)
      const controllerType = args[1] // UNSPECIFIED (0), PI_P (1), P_PI (2)
        ? parseInt(args[1], 10)
        : MotionMasterMessage.Request.StartFullAutoTuning.ControllerType.UNSPECIFIED;

      switch (tuningType) {
        case 0: {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.FullAutoTuning.Success.Code.POSITION_DONE);

          motionMasterClient.requestStartFullAutoTuning(deviceAddress, tuningType, controllerType, messageId);

          break;
        }
        case 1: {
          exitOnMessageReceived(messageId, 10000, MotionMasterMessage.Status.FullAutoTuning.Success.Code.VELOCITY_DONE);

          motionMasterClient.requestStartFullAutoTuning(deviceAddress, tuningType, controllerType, messageId);

          break;
        }
        default: {
          throw new Error(`Unknown start auto-tuning type: ${tuningType}`);
        }
      }
      break;
    }
    case 'stopFullAutoTuning': {
      motionMasterClient.requestStopFullAutoTuning(deviceAddress, messageId);

      break;
    }
    default: {
      throw new Error(`Request "${type}" doesn\'t exist`);
    }
  }
}

async function uploadAction(params: string[], cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);
  const sendProgress = cmd.sendProgress;

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId);

  const parameters: MotionMasterMessage.Request.GetDeviceParameterValues.IParameter[] = params.map(paramToIndexSubindex);
  validateParameters(parameters);
  const getDeviceParameterValues: MotionMasterMessage.Request.IGetDeviceParameterValues = { deviceAddress, parameters, sendProgress };

  motionMasterClient.sendRequest({ getDeviceParameterValues }, messageId);
}

async function downloadAction(paramValues: string[], cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId);

  const deviceParameterInfo = await getDeviceParameterInfoAsync(deviceAddress);
  const parameterValues = paramValues.map((paramValue) => paramToIndexSubIndexValue(paramValue, deviceParameterInfo));
  const setDeviceParameterValues: MotionMasterMessage.Request.ISetDeviceParameterValues = { deviceAddress, parameterValues };

  motionMasterClient.sendRequest({ setDeviceParameterValues }, messageId);
}

async function getDeviceFileContentAction(name: string, cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();

  motionMasterClient.selectMessage(messageId).pipe(
    first(),
  ).subscribe((message) => {
    if (message && message.status && message.status.deviceFile) {
      const error = message.status.deviceFile.error;
      if (error) {
        throw new Error(`${error.code}: ${error.message}`);
      } else {
        const content = message.status.deviceFile.content;
        if (content) {
          const contentDecoded = new StringDecoder('utf-8').write(Buffer.from(content));
          console.log(contentDecoded);
          process.exit(ExitStatus.SUCCESS);
        } else {
          throw new Error('Device file content is empty');
        }
      }
    } else {
      throw new Error('The received message is not "deviceFile"');
    }
  });

  const getDeviceFile: MotionMasterMessage.Request.IGetDeviceFile = { deviceAddress, name };

  motionMasterClient.sendRequest({ getDeviceFile }, messageId);
}

async function getDeviceLogContentAction(cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();

  motionMasterClient.selectMessage(messageId).pipe(
    first(),
  ).subscribe((message) => {
    if (message && message.status && message.status.deviceLog) {
      const error = message.status.deviceLog.error;
      if (error) {
        throw new Error(`${error.code}: ${error.message}`);
      } else {
        const content = message.status.deviceLog.content;
        if (content) {
          const contentDecoded = new StringDecoder('utf-8').write(Buffer.from(content));
          console.log(contentDecoded);
          process.exit(ExitStatus.SUCCESS);
        } else {
          throw new Error('Device log content is empty');
        }
      }
    } else {
      throw new Error('The received message is not "deviceLog"');
    }
  });

  const getDeviceLog: MotionMasterMessage.Request.IGetDeviceLog = { deviceAddress };

  motionMasterClient.sendRequest({ getDeviceLog }, messageId);
}

async function getCoggingTorqueDataContent(cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();

  motionMasterClient.selectMessage(messageId).pipe(
    first(),
  ).subscribe((message) => {
    if (message && message.status && message.status.coggingTorqueData) {
      const error = message.status.coggingTorqueData.error;
      if (error) {
        throw new Error(`${error.code}: ${error.message}`);
      } else {
        const table = message.status.coggingTorqueData.table;
        if (table && table.data) {
          console.log(table.data.join(', '));
          process.exit(ExitStatus.SUCCESS);
        } else {
          throw new Error('Cogging torque table content data is empty');
        }
      }
    } else {
      throw new Error('The received message is not "coggingTorqueData"');
    }
  });

  const getCoggingTorqueData: MotionMasterMessage.Request.IGetCoggingTorqueData = { deviceAddress };

  motionMasterClient.sendRequest({ getCoggingTorqueData }, messageId);
}

async function startOffsetDetectionAction(cmd: Command) {
  connectToMotionMaster(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId, 180000, MotionMasterMessage.Status.OffsetDetection.Success.Code.DONE);

  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);
  const startOffsetDetection: MotionMasterMessage.Request.IStartOffsetDetection = { deviceAddress };

  motionMasterClient.sendRequest({ startOffsetDetection }, messageId);
}

async function startCoggingTorqueRecordingAction(cmd: Command) {
  connectToMotionMaster(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId, 300000, MotionMasterMessage.Status.CoggingTorqueRecording.Success.Code.DONE);

  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);
  const skipAutoTuning = cmd.skipAutoTuning;
  const startCoggingTorqueRecording: MotionMasterMessage.Request.IStartCoggingTorqueRecording = { deviceAddress, skipAutoTuning };

  motionMasterClient.sendRequest({ startCoggingTorqueRecording }, messageId);
}

async function startPlantIdentificationAction(
  durationSeconds: any,
  torqueAmplitude: any,
  startFrequency: any,
  endFrequency: any,
  cutoffFrequency: any,
  cmd: Command,
) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.PlantIdentification.Success.Code.DONE);

  durationSeconds = parseFloat(durationSeconds);
  torqueAmplitude = parseInt(torqueAmplitude, 10);
  startFrequency = parseInt(startFrequency, 10);
  endFrequency = parseInt(endFrequency, 10);
  cutoffFrequency = parseInt(cutoffFrequency, 10);

  const startPlantIdentification: MotionMasterMessage.Request.IStartPlantIdentification = {
    deviceAddress,
    durationSeconds,
    torqueAmplitude,
    startFrequency,
    endFrequency,
    cutoffFrequency,
  };

  motionMasterClient.sendRequest({ startPlantIdentification }, messageId);
}

async function startSystemIdentificationAction(
  durationSeconds: any,
  torqueAmplitude: any,
  startFrequency: any,
  endFrequency: any,
  cmd: Command,
) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.SystemIdentification.Success.Code.DONE);

  durationSeconds = parseFloat(durationSeconds);
  torqueAmplitude = parseInt(torqueAmplitude, 10);
  startFrequency = parseFloat(startFrequency);
  endFrequency = parseFloat(endFrequency);

  const startSystemIdentification: MotionMasterMessage.Request.IStartSystemIdentification = {
    deviceAddress,
    durationSeconds,
    torqueAmplitude,
    startFrequency,
    endFrequency,
  };

  motionMasterClient.sendRequest({ startSystemIdentification }, messageId);
}

async function startCirculoEncoderNarrowAngleCalibrationProcedureAction(
  encoderPort: any,
  cmd: Command,
) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const messageId = v4();
  printOnMessageReceived(messageId, cmd.parent.outputFormat as OutputFormat);
  exitOnMessageReceived(messageId, 60000, MotionMasterMessage.Status.CirculoEncoderNarrowAngleCalibrationProcedure.Success.Code.DONE);

  encoderPort = parseInt(encoderPort, 10);

  const startCirculoEncoderNarrowAngleCalibrationProcedure: MotionMasterMessage.Request.IStartCirculoEncoderNarrowAngleCalibrationProcedure = {
    deviceAddress,
    encoderPort,
  };

  motionMasterClient.sendRequest({ startCirculoEncoderNarrowAngleCalibrationProcedure }, messageId);
}

async function monitorAction(topic: string, params: string[], cmd: Command) {
  connectToMotionMaster(cmd.parent);
  const deviceAddress = await getCommandDeviceAddressAsync(cmd.parent);

  const parameters = params.map(paramToIndexSubindex);
  const getDeviceParameterValues = { deviceAddress, parameters };

  requestStartMonitoringDeviceParameterValues({ getDeviceParameterValues, interval: cmd.interval, topic });
}

//
// helper functions
//

function connectToMotionMaster(cmd: Command) {

  if (cmd.config) {
    const contents = fs.readFileSync(cmd.config, { encoding: 'utf8' });
    const json = JSON.parse(contents);
    Object.assign(config, json);
  }

  // ping Motion Master in regular intervals
  const pingSystemInterval = interval(config.pingSystemInterval);
  pingSystemInterval.subscribe(() => motionMasterClient.sendRequest({ pingSystem: {} }));

  // connect to server endpoint
  const serverSocket = zmq.socket('dealer');
  debug(`Using identity for ZeroMQ DEALER socket: ${config.identity}`);
  serverSocket.identity = config.identity;
  serverSocket.connect(config.serverEndpoint);
  debug(`Connected to ZeroMQ DEALER socket server endpoint: ${config.serverEndpoint}`);

  // feed data coming from Motion Master to MotionMasterClient
  serverSocket.on('message', (data) => {
    motionMasterClient.input$.next(decodeMotionMasterMessage(data));
  });

  // send data fed from MotionMasterClient to Motion Master
  motionMasterClient.output$.subscribe((message) => {
    // log outgoing messages and skip ping messages
    if (!(message && message.request && message.request.pingSystem)) {
      debug(
        util.inspect(message, inspectOptions),
      );
    }
    serverSocket.send(Buffer.from(encodeMotionMasterMessage(message)));
  });

  // connnect to notification endpoint
  const notificationSocket = zmq.socket('sub').connect(config.notificationEndpoint);
  debug(`Connected to ZeroMQ SUB socket notification endpoint: ${config.notificationEndpoint}`);

  // subscribe to all topics
  notificationSocket.subscribe('');

  // exit process when a heartbeat message is not received for more than the time specified
  motionMasterClient.selectMessageStatus('systemPong').pipe(
    timeout(config.motionMasterHeartbeatTimeoutDue),
  ).subscribe({
    error: (err) => {
      console.error(`${err.name}: Heartbeat message not received for more than ${config.motionMasterHeartbeatTimeoutDue} ms. Check if Motion Master process is running.`);
      process.exit(ExitStatus.TIMEOUT);
    },
  });

  // feed notification data coming from Motion Master to MotionMasterNotification
  notificationSocket.on('message', (topic: Uint8Array, message: Uint8Array) => {
    motionMasterNotification.input$.next({ topic: topic.toString(), messages: [decodeMotionMasterMessage(message)] });
  });
}

function requestStartMonitoringDeviceParameterValues(startMonitoringDeviceParameterValues: MotionMasterMessage.Request.IStartMonitoringDeviceParameterValues) {
  const messageId = v4();

  motionMasterNotification.selectMessagesByTopic(startMonitoringDeviceParameterValues.topic || '').subscribe((messages) => {
    const timestamp = Date.now();
    const topic = startMonitoringDeviceParameterValues.topic;
    console.log(
      util.inspect({ timestamp, topic, messages }, inspectOptions),
    );
  });

  motionMasterClient.sendRequest({ startMonitoringDeviceParameterValues }, messageId);
}

async function getDeviceParameterInfoAsync(deviceAddress: DeviceAddressType) {
  if (!deviceAddress) {
    return null;
  }

  if (deviceParameterInfoMap.has(deviceAddress)) {
    return deviceParameterInfoMap.get(deviceAddress); // retrieve from cache
  }

  const getDeviceParameterInfo = { deviceAddress };
  const messageId = v4();
  motionMasterClient.sendRequest({ getDeviceParameterInfo }, messageId);

  const deviceParameterInfo = await motionMasterClient.selectMessage(messageId).pipe(
    first(),
    map((message) => message && message.status ? message.status.deviceParameterInfo : null),
  ).toPromise();

  deviceParameterInfoMap.set(deviceAddress, deviceParameterInfo); // cache

  return deviceParameterInfo;
}

function paramToIndexSubindex(paramValue: string) {
  const [indexStr, subindexStr] = paramValue.split(':');
  const index = parseInt(indexStr, 16);
  const subindex = parseInt(subindexStr, 10) || 0;
  return { index, subindex };
}

function paramToIndexSubIndexValue(paramValue: string, deviceParameterInfo: MotionMasterMessage.Status.IDeviceParameterInfo | null | undefined) {
  const [param, value] = paramValue.split('=');
  const { index, subindex } = paramToIndexSubindex(param);

  const parameterValue: MotionMasterMessage.Status.DeviceParameterValues.IParameterValue = { index, subindex };

  if (deviceParameterInfo) {
    if (deviceParameterInfo.parameters) {
      const parameter = deviceParameterInfo.parameters.find((p) => p.index === index && p.subindex === subindex);
      if (parameter) {
        const VT = MotionMasterMessage.Status.DeviceParameterInfo.Parameter.ValueType;
        switch (parameter.valueType) {
          case VT.UNSPECIFIED:
          case VT.INTEGER8:
          case VT.INTEGER16:
          case VT.INTEGER32: {
            parameterValue.intValue = parseInt(value, 10);
            break;
          }
          case VT.BOOLEAN:
          case VT.UNSIGNED8:
          case VT.UNSIGNED16:
          case VT.UNSIGNED32: {
            parameterValue.uintValue = parseInt(value, 10);
            break;
          }
          case VT.REAL32: {
            parameterValue.floatValue = parseFloat(value);
            break;
          }
          case VT.VISIBLE_STRING:
          case VT.OCTET_STRING:
          case VT.UNICODE_STRING:
          case VT.TIME_OF_DAY: {
            parameterValue.stringValue = value;
            break;
          }
        }
      }
    }
  }

  return parameterValue;
}

function validateParameters(parameters: MotionMasterMessage.Request.GetDeviceParameterValues.IParameter[]) {
  let error = null;

  if (parameters.some((p) => p.index === 0)) {
    error = new Error('Parameter with index 0 is requested.');
  }

  if (parameters.some((p) => isNaN(p.index as number) || isNaN(p.subindex as number))) {
    error = new Error('Parameter with unparsable index or subindex is requested.');
  }

  if (error) {
    error.message += '\nExample of correct formats: "0x2002 0x100A:0 0x2003:4".';
    console.error(`${error.name}: ${error.message}`);
    console.error(util.inspect(parameters, inspectOptions));
    process.exit(ExitStatus.INCORRECT_PARAMETER_FORMAT);
  }
}

async function getCommandDeviceAddressAsync(cmd: Command): Promise<DeviceAddressType | null> {
  if (cmd.deviceAddress) {
    return cmd.deviceAddress;
  } else if (Number.isInteger(cmd.devicePosition)) {
    const device = await motionMasterClient.selectDeviceAtPosition(cmd.devicePosition).toPromise();
    if (device) {
      return device.deviceAddress;
    } else {
      console.warn(`WARNING: Cannot get device at position ${cmd.devicePosition} or device list is empty.`);
      return null;
    }
  } else {
    return null;
  }
}

function exitOnMessageReceived(messageId: string, due = 10000, exitOnSuccessCode?: number) {
  motionMasterClient.selectMessage(messageId).pipe(
    first((message) => {
      if (exitOnSuccessCode === undefined) {
        return true;
      } else {
        if (message && message.status) {
          const key = Object.keys(message.status)[0] as StatusType;
          const status = message.status[key] as { success: any, error: any };
          if (status && ((status.success && status.success.code === exitOnSuccessCode) || status.error)) {
            return true;
          }
        }
        return false;
      }
    }),
    timeout(due),
  ).subscribe({
    next: () => {
      debug(`Exit on message received ${messageId}`);
      process.exit(ExitStatus.SUCCESS);
    },
    error: (err) => {
      console.error(`${err.name}: Status message ${messageId} not received for more than ${due} ms.`);
      process.exit(ExitStatus.TIMEOUT);
    },
  });
}

function printOnMessageReceived(messageId: string, outputFormat: OutputFormat = 'inspect') {
  motionMasterClient.selectMessage(messageId).subscribe((message) => {
    const timestamp = Date.now();
    const outputObj = { timestamp, message };

    switch (outputFormat) {
      case 'json': {
        console.log(JSON.stringify(outputObj));
        break;
      }
      case 'yaml': {
        console.log(YAML.stringify(outputObj));
        break;
      }
      default: {
        console.log(
          util.inspect(outputObj, inspectOptions),
        );
      }
    }
  });
}

function parseOptionValueAsInt(value: string) {
  return parseInt(value, 10);
}
