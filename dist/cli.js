#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var commander_1 = __importDefault(require("commander"));
var fs_1 = __importDefault(require("fs"));
var motion_master_proto_1 = require("motion-master-proto");
var path_1 = __importDefault(require("path"));
var rxjs = __importStar(require("rxjs"));
var operators_1 = require("rxjs/operators");
var string_decoder_1 = require("string_decoder");
var util_1 = __importDefault(require("util"));
var uuid_1 = require("uuid");
var yaml_1 = __importDefault(require("yaml"));
var zeromq_1 = __importDefault(require("zeromq"));
var motion_master_client_1 = require("./motion-master-client");
// tslint:disable: no-var-requires
var debug = require('debug')('motion-master-client');
var version = require('../package.json')['version'];
// tslint:enable-next-line: no-var-requires
process.on('uncaughtException', function (err) {
    console.error('Caught exception: ' + err);
    process.exit(-2);
});
process.on('unhandledRejection', function (reason) {
    console.error('Unhandled rejection reason: ', reason);
    process.exit(-3);
});
var inspectOptions = {
    showHidden: false,
    depth: null,
    colors: true,
    maxArrayLength: null,
    compact: false,
};
// map to cache device parameter info per device
var deviceParameterInfoMap = new Map();
var input = new rxjs.Subject();
var output = new rxjs.Subject();
var notification = new rxjs.Subject();
var motionMasterClient = new motion_master_client_1.MotionMasterClient(input, output, notification);
var config = {
    pingSystemInterval: 200,
    motionMasterHeartbeatTimeoutDue: 1000,
    serverEndpoint: 'tcp://127.0.0.1:62524',
    notificationEndpoint: 'tcp://127.0.0.1:62525',
    identity: uuid_1.v4(),
};
//
// program and commands
//
commander_1.default
    .version(version)
    .option('-c, --config <path>', 'path to JSON config file to read and replace the default values with')
    .option('-d, --device-address <address>', 'device address (uint32) generated by Motion Master - takes precedence over device position', parseOptionValueAsInt)
    .option('-f, --output-format <json|yaml>', 'if left unspecified the output is colored inspect of the received message')
    .option('-p, --device-position <position>', 'used when device address is not specified', parseOptionValueAsInt, 0);
commander_1.default
    .command('request <type> [args...]')
    .option('-i, --interval <value>', 'sending interval in microseconds', parseOptionValueAsInt, 1 * 1000 * 1000)
    .on('--help', function () {
    var types = Object.keys(motion_master_proto_1.motionmaster.MotionMasterMessage.Request).slice(8).map(function (type) { return type.charAt(0).toLowerCase() + type.slice(1); });
    console.log('');
    console.log('Request <type>s:');
    console.log('  ' + types.join('\n  '));
})
    .action(requestAction);
commander_1.default
    .command('upload [params...]')
    .action(uploadAction);
commander_1.default
    .command('download [paramValues...]')
    .action(downloadAction);
commander_1.default
    .command('getDeviceFileContent <filename>')
    .action(getDeviceFileContentAction);
commander_1.default
    .command('startCoggingTorqueRecording')
    .option('-s, --skip-auto-tuning')
    .action(startCoggingTorqueRecordingAction);
commander_1.default
    .command('startOffsetDetection')
    .action(startOffsetDetectionAction);
commander_1.default
    .command('startPlantIdentification <durationSeconds> <torqueAmplitude> <startFrequency> <endFrequency> <cutoffFrequency>')
    .action(startPlantIdentificationAction);
commander_1.default
    .command('monitor <topic> [params...]')
    .option('-i, --interval <value>', 'sending interval in microseconds', parseOptionValueAsInt, 1 * 1000 * 1000)
    .action(monitorAction);
// parse command line arguments and execute the command action
commander_1.default.parse(process.argv);
//
// command action functions
//
function requestAction(type, args, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, messageId, _a, pingSystem, getSystemVersion, getDeviceInfo, getDeviceParameterInfo, parameters, getDeviceParameterValues, deviceParameterInfo_1, parameterValues, setDeviceParameterValues, getDeviceFileList, name_1, getDeviceFile, filepath, content, name_2, overwrite, setDeviceFile, name_3, deleteDeviceFile, resetDeviceFault, stopDevice, filepath, firmwarePackageContent, startDeviceFirmwareInstallation, getDeviceLog, skipAutoTuning, startCoggingTorqueRecording, getCoggingTorqueData, startOffsetDetection, durationSeconds, torqueAmplitude, startFrequency, endFrequency, cutoffFrequency, startPlantIdentification, controllerType, settlingTime, positionDamping, alphaMult, order, lb, ub, computeAutoTuningGains, velocityLoopBandwidth, velocityDamping, computeAutoTuningGains, controllerType, filter, enableMotionController, disableMotionController, parameters, getDeviceParameterValues, interval, topic, startMonitoringRequestId, stopMonitoringDeviceParameterValues;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _b.sent();
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    _a = type;
                    switch (_a) {
                        case 'pingSystem': return [3 /*break*/, 2];
                        case 'getSystemVersion': return [3 /*break*/, 3];
                        case 'getDeviceInfo': return [3 /*break*/, 4];
                        case 'getDeviceParameterInfo': return [3 /*break*/, 5];
                        case 'getDeviceParameterValues': return [3 /*break*/, 6];
                        case 'getMultiDeviceParameterValues': return [3 /*break*/, 7];
                        case 'setDeviceParameterValues': return [3 /*break*/, 8];
                        case 'setMultiDeviceParameterValues': return [3 /*break*/, 10];
                        case 'getDeviceFileList': return [3 /*break*/, 11];
                        case 'getDeviceFile': return [3 /*break*/, 12];
                        case 'setDeviceFile': return [3 /*break*/, 13];
                        case 'deleteDeviceFile': return [3 /*break*/, 14];
                        case 'resetDeviceFault': return [3 /*break*/, 15];
                        case 'stopDevice': return [3 /*break*/, 16];
                        case 'startDeviceFirmwareInstallation': return [3 /*break*/, 17];
                        case 'getDeviceLog': return [3 /*break*/, 18];
                        case 'startCoggingTorqueRecording': return [3 /*break*/, 19];
                        case 'getCoggingTorqueData': return [3 /*break*/, 20];
                        case 'startOffsetDetection': return [3 /*break*/, 21];
                        case 'startPlantIdentification': return [3 /*break*/, 22];
                        case 'computeAutoTuningGains': return [3 /*break*/, 23];
                        case 'setMotionControllerParameters': return [3 /*break*/, 24];
                        case 'enableMotionController': return [3 /*break*/, 25];
                        case 'disableMotionController': return [3 /*break*/, 26];
                        case 'setSignalGeneratorParameters': return [3 /*break*/, 27];
                        case 'startSignalGenerator': return [3 /*break*/, 28];
                        case 'stopSignalGenerator': return [3 /*break*/, 29];
                        case 'startMonitoringDeviceParameterValues': return [3 /*break*/, 30];
                        case 'stopMonitoringDeviceParameterValues': return [3 /*break*/, 31];
                    }
                    return [3 /*break*/, 32];
                case 2:
                    {
                        pingSystem = {};
                        motionMasterClient.sendRequest({ pingSystem: pingSystem }, messageId);
                        process.exit(0);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 3;
                case 3:
                    {
                        exitOnMessageReceived(messageId);
                        getSystemVersion = {};
                        motionMasterClient.sendRequest({ getSystemVersion: getSystemVersion }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 4;
                case 4:
                    {
                        exitOnMessageReceived(messageId);
                        getDeviceInfo = {};
                        motionMasterClient.sendRequest({ getDeviceInfo: getDeviceInfo }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 5;
                case 5:
                    {
                        exitOnMessageReceived(messageId);
                        getDeviceParameterInfo = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ getDeviceParameterInfo: getDeviceParameterInfo }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 6;
                case 6:
                    {
                        exitOnMessageReceived(messageId);
                        parameters = args.map(paramToIndexSubindex);
                        getDeviceParameterValues = { deviceAddress: deviceAddress, parameters: parameters };
                        motionMasterClient.sendRequest({ getDeviceParameterValues: getDeviceParameterValues }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 7;
                case 7:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 8;
                case 8:
                    exitOnMessageReceived(messageId);
                    return [4 /*yield*/, getDeviceParameterInfoAsync(deviceAddress)];
                case 9:
                    deviceParameterInfo_1 = _b.sent();
                    parameterValues = args.map(function (paramValue) { return paramToIndexSubIndexValue(paramValue, deviceParameterInfo_1); });
                    setDeviceParameterValues = { deviceAddress: deviceAddress, parameterValues: parameterValues };
                    motionMasterClient.sendRequest({ setDeviceParameterValues: setDeviceParameterValues }, messageId);
                    return [3 /*break*/, 33];
                case 10:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 11;
                case 11:
                    {
                        exitOnMessageReceived(messageId);
                        getDeviceFileList = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ getDeviceFileList: getDeviceFileList }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 12;
                case 12:
                    {
                        exitOnMessageReceived(messageId);
                        name_1 = args[0];
                        getDeviceFile = { deviceAddress: deviceAddress, name: name_1 };
                        motionMasterClient.sendRequest({ getDeviceFile: getDeviceFile }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 13;
                case 13:
                    {
                        exitOnMessageReceived(messageId);
                        filepath = args[0];
                        content = fs_1.default.readFileSync(filepath);
                        name_2 = path_1.default.basename(filepath);
                        overwrite = true;
                        setDeviceFile = { deviceAddress: deviceAddress, name: name_2, content: content, overwrite: overwrite };
                        motionMasterClient.sendRequest({ setDeviceFile: setDeviceFile }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 14;
                case 14:
                    {
                        exitOnMessageReceived(messageId);
                        name_3 = args[0];
                        deleteDeviceFile = { deviceAddress: deviceAddress, name: name_3 };
                        motionMasterClient.sendRequest({ deleteDeviceFile: deleteDeviceFile }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 15;
                case 15:
                    {
                        exitOnMessageReceived(messageId);
                        resetDeviceFault = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ resetDeviceFault: resetDeviceFault }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 16;
                case 16:
                    {
                        stopDevice = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ stopDevice: stopDevice }, messageId);
                        process.exit(0);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 17;
                case 17:
                    {
                        exitOnMessageReceived(messageId, 120000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.DeviceFirmwareInstallation.Success.Code.DONE);
                        filepath = args[0];
                        firmwarePackageContent = fs_1.default.readFileSync(filepath);
                        startDeviceFirmwareInstallation = { deviceAddress: deviceAddress, firmwarePackageContent: firmwarePackageContent };
                        motionMasterClient.sendRequest({ startDeviceFirmwareInstallation: startDeviceFirmwareInstallation }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 18;
                case 18:
                    {
                        exitOnMessageReceived(messageId);
                        getDeviceLog = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ getDeviceLog: getDeviceLog }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 19;
                case 19:
                    {
                        exitOnMessageReceived(messageId, 300000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.CoggingTorqueRecording.Success.Code.DONE);
                        skipAutoTuning = args[0] === 'true' || false;
                        startCoggingTorqueRecording = { deviceAddress: deviceAddress, skipAutoTuning: skipAutoTuning };
                        motionMasterClient.sendRequest({ startCoggingTorqueRecording: startCoggingTorqueRecording }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 20;
                case 20:
                    {
                        exitOnMessageReceived(messageId);
                        getCoggingTorqueData = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ getCoggingTorqueData: getCoggingTorqueData }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 21;
                case 21:
                    {
                        exitOnMessageReceived(messageId, 180000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.OffsetDetection.Success.Code.DONE);
                        startOffsetDetection = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ startOffsetDetection: startOffsetDetection }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 22;
                case 22:
                    {
                        exitOnMessageReceived(messageId, 60000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.PlantIdentification.Success.Code.DONE);
                        durationSeconds = parseFloat(args[0]);
                        torqueAmplitude = parseInt(args[1], 10);
                        startFrequency = parseInt(args[2], 10);
                        endFrequency = parseInt(args[3], 10);
                        cutoffFrequency = parseInt(args[4], 10);
                        startPlantIdentification = {
                            deviceAddress: deviceAddress,
                            durationSeconds: durationSeconds,
                            torqueAmplitude: torqueAmplitude,
                            startFrequency: startFrequency,
                            endFrequency: endFrequency,
                            cutoffFrequency: cutoffFrequency,
                        };
                        motionMasterClient.sendRequest({ startPlantIdentification: startPlantIdentification }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 23;
                case 23:
                    {
                        if (args[0] === 'position') {
                            exitOnMessageReceived(messageId, 10000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.AutoTuning.Success.Code.POSITION_DONE);
                            controllerType = parseInt(args[1], 10);
                            settlingTime = parseFloat(args[2]);
                            positionDamping = parseFloat(args[3]);
                            alphaMult = parseInt(args[4], 10);
                            order = parseInt(args[5], 10);
                            lb = parseFloat(args[6]);
                            ub = parseFloat(args[7]);
                            computeAutoTuningGains = {
                                deviceAddress: deviceAddress,
                                positionParameters: {
                                    controllerType: controllerType,
                                    settlingTime: settlingTime,
                                    positionDamping: positionDamping,
                                    alphaMult: alphaMult,
                                    order: order,
                                    lb: lb,
                                    ub: ub,
                                },
                            };
                            motionMasterClient.sendRequest({ computeAutoTuningGains: computeAutoTuningGains }, messageId);
                        }
                        else if (args[0] === 'velocity') {
                            exitOnMessageReceived(messageId, 10000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.AutoTuning.Success.Code.VELOCITY_DONE);
                            velocityLoopBandwidth = parseFloat(args[1]);
                            velocityDamping = parseFloat(args[2]);
                            computeAutoTuningGains = {
                                deviceAddress: deviceAddress,
                                velocityParameters: {
                                    velocityLoopBandwidth: velocityLoopBandwidth,
                                    velocityDamping: velocityDamping,
                                },
                            };
                            motionMasterClient.sendRequest({ computeAutoTuningGains: computeAutoTuningGains }, messageId);
                        }
                        else {
                            throw new Error("Unknown compute auto-tuning gains \"" + args[0] + "\" type.");
                        }
                        return [3 /*break*/, 33];
                    }
                    _b.label = 24;
                case 24:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 25;
                case 25:
                    {
                        exitOnMessageReceived(messageId);
                        controllerType = parseInt(args[0], 10);
                        filter = args[1] === 'true' || false;
                        enableMotionController = {
                            deviceAddress: deviceAddress,
                            controllerType: controllerType,
                            filter: filter,
                        };
                        motionMasterClient.sendRequest({ enableMotionController: enableMotionController }, messageId);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 26;
                case 26:
                    {
                        disableMotionController = { deviceAddress: deviceAddress };
                        motionMasterClient.sendRequest({ disableMotionController: disableMotionController }, messageId);
                        process.exit(0);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 27;
                case 27:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 28;
                case 28:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 29;
                case 29:
                    {
                        throw new Error("Request \"" + type + "\" is not yet implemented");
                    }
                    _b.label = 30;
                case 30:
                    {
                        parameters = args.slice(1).map(paramToIndexSubindex);
                        getDeviceParameterValues = { deviceAddress: deviceAddress, parameters: parameters };
                        interval = cmd.interval;
                        topic = args[0];
                        requestStartMonitoringDeviceParameterValues({ getDeviceParameterValues: getDeviceParameterValues, interval: interval, topic: topic });
                        return [3 /*break*/, 33];
                    }
                    _b.label = 31;
                case 31:
                    {
                        startMonitoringRequestId = args[0];
                        stopMonitoringDeviceParameterValues = { startMonitoringRequestId: startMonitoringRequestId };
                        motionMasterClient.sendRequest({ stopMonitoringDeviceParameterValues: stopMonitoringDeviceParameterValues }, messageId);
                        process.exit(0);
                        return [3 /*break*/, 33];
                    }
                    _b.label = 32;
                case 32:
                    {
                        throw new Error("Request \"" + type + "\" doesn't exist");
                    }
                    _b.label = 33;
                case 33: return [2 /*return*/];
            }
        });
    });
}
function uploadAction(params, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, messageId, parameters, getDeviceParameterValues;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    exitOnMessageReceived(messageId);
                    parameters = params.map(paramToIndexSubindex);
                    getDeviceParameterValues = { deviceAddress: deviceAddress, parameters: parameters };
                    motionMasterClient.sendRequest({ getDeviceParameterValues: getDeviceParameterValues }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function downloadAction(paramValues, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, messageId, deviceParameterInfo, parameterValues, setDeviceParameterValues;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    exitOnMessageReceived(messageId);
                    return [4 /*yield*/, getDeviceParameterInfoAsync(deviceAddress)];
                case 2:
                    deviceParameterInfo = _a.sent();
                    parameterValues = paramValues.map(function (paramValue) { return paramToIndexSubIndexValue(paramValue, deviceParameterInfo); });
                    setDeviceParameterValues = { deviceAddress: deviceAddress, parameterValues: parameterValues };
                    motionMasterClient.sendRequest({ setDeviceParameterValues: setDeviceParameterValues }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function getDeviceFileContentAction(name, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, messageId, getDeviceFile;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    messageId = uuid_1.v4();
                    motionMasterClient.filterMotionMasterMessageById$(messageId).pipe(operators_1.first()).subscribe(function (message) {
                        if (message && message.status && message.status.deviceFile) {
                            var error = message.status.deviceFile.error;
                            if (error) {
                                throw new Error(error.code + ": " + error.message);
                            }
                            else {
                                var content = message.status.deviceFile.content;
                                if (content) {
                                    var contentDecoded = new string_decoder_1.StringDecoder('utf-8').write(new Buffer(content));
                                    console.log(contentDecoded);
                                    process.exit(0);
                                }
                            }
                        }
                        throw new Error("There was an error getting device file \"" + name + "\".");
                    });
                    getDeviceFile = { deviceAddress: deviceAddress, name: name };
                    motionMasterClient.sendRequest({ getDeviceFile: getDeviceFile }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function startOffsetDetectionAction(cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var messageId, deviceAddress, startOffsetDetection;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    exitOnMessageReceived(messageId, 180000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.OffsetDetection.Success.Code.DONE);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    startOffsetDetection = { deviceAddress: deviceAddress };
                    motionMasterClient.sendRequest({ startOffsetDetection: startOffsetDetection }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function startCoggingTorqueRecordingAction(cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var messageId, deviceAddress, skipAutoTuning, startCoggingTorqueRecording;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    exitOnMessageReceived(messageId, 300000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.CoggingTorqueRecording.Success.Code.DONE);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    skipAutoTuning = cmd.skipAutoTuning;
                    startCoggingTorqueRecording = { deviceAddress: deviceAddress, skipAutoTuning: skipAutoTuning };
                    motionMasterClient.sendRequest({ startCoggingTorqueRecording: startCoggingTorqueRecording }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function startPlantIdentificationAction(durationSeconds, torqueAmplitude, startFrequency, endFrequency, cutoffFrequency, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, messageId, startPlantIdentification;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    messageId = uuid_1.v4();
                    printOnMessageReceived(messageId, cmd.parent.outputFormat);
                    exitOnMessageReceived(messageId, 60000, motion_master_proto_1.motionmaster.MotionMasterMessage.Status.PlantIdentification.Success.Code.DONE);
                    startPlantIdentification = {
                        deviceAddress: deviceAddress,
                        durationSeconds: durationSeconds,
                        torqueAmplitude: torqueAmplitude,
                        startFrequency: startFrequency,
                        endFrequency: endFrequency,
                        cutoffFrequency: cutoffFrequency,
                    };
                    motionMasterClient.sendRequest({ startPlantIdentification: startPlantIdentification }, messageId);
                    return [2 /*return*/];
            }
        });
    });
}
function monitorAction(topic, params, cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var deviceAddress, parameters, getDeviceParameterValues, interval;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectToMotionMaster(cmd.parent);
                    return [4 /*yield*/, getCommandDeviceAddressAsync(cmd.parent)];
                case 1:
                    deviceAddress = _a.sent();
                    parameters = params.map(paramToIndexSubindex);
                    getDeviceParameterValues = { deviceAddress: deviceAddress, parameters: parameters };
                    interval = cmd.interval;
                    requestStartMonitoringDeviceParameterValues({ getDeviceParameterValues: getDeviceParameterValues, interval: interval, topic: topic });
                    return [2 /*return*/];
            }
        });
    });
}
//
// helper functions
//
function connectToMotionMaster(cmd) {
    if (cmd.config) {
        var contents = fs_1.default.readFileSync(cmd.config, { encoding: 'utf8' });
        var json = JSON.parse(contents);
        Object.assign(config, json);
    }
    // ping Motion Master in regular intervals
    var pingSystemInterval = rxjs.interval(config.pingSystemInterval);
    pingSystemInterval.subscribe(function () { return motionMasterClient.sendRequest({ pingSystem: {} }); });
    // connect to server endpoint
    var serverSocket = zeromq_1.default.socket('dealer');
    debug("Identity: " + config.identity);
    serverSocket.identity = config.identity;
    serverSocket.connect(config.serverEndpoint);
    debug("ZeroMQ DEALER socket is connected to server endpoint: " + config.serverEndpoint);
    // feed buffer data coming from Motion Master to MotionMasterClient
    serverSocket.on('message', function (data) {
        input.next(data);
    });
    // send buffer data fed from MotionMasterClient to Motion Master
    output.subscribe(function (buffer) {
        var message = motion_master_client_1.decodeMotionMasterMessage(buffer);
        // log outgoing messages and skip ping messages
        if (!(message && message.request && message.request.pingSystem)) {
            debug(util_1.default.inspect(motion_master_client_1.decodeMotionMasterMessage(buffer).toJSON(), inspectOptions));
        }
        serverSocket.send(buffer);
    });
    // connnect to notification endpoint
    var notificationSocket = zeromq_1.default.socket('sub').connect(config.notificationEndpoint);
    debug("ZeroMQ SUB socket connected to notification endpoint: " + config.notificationEndpoint);
    // subscribe to all topics
    notificationSocket.subscribe('');
    // exit process when a heartbeat message is not received for more than the time specified
    motionMasterClient.filterNotificationByTopic$('heartbeat').pipe(operators_1.timeout(config.motionMasterHeartbeatTimeoutDue)).subscribe({
        error: function (err) {
            console.error(err.name + ": Heartbeat message not received for more than " + config.motionMasterHeartbeatTimeoutDue + " ms. Check if Motion Master process is running.");
            process.exit(-1);
        },
    });
    // feed notification buffer data coming from Motion Master to MotionMasterClient
    notificationSocket.on('message', function (topic, message) {
        notification.next([topic, message]);
    });
}
function requestStartMonitoringDeviceParameterValues(startMonitoringDeviceParameterValues) {
    var messageId = uuid_1.v4();
    motionMasterClient.filterNotificationByTopic$(startMonitoringDeviceParameterValues.topic).subscribe(function (notif) {
        var timestamp = Date.now();
        var topic = startMonitoringDeviceParameterValues.topic;
        var message = notif.message;
        console.log(util_1.default.inspect({ timestamp: timestamp, topic: topic, message: message }, inspectOptions));
    });
    motionMasterClient.sendRequest({ startMonitoringDeviceParameterValues: startMonitoringDeviceParameterValues }, messageId);
}
function getDeviceParameterInfoAsync(deviceAddress) {
    return __awaiter(this, void 0, void 0, function () {
        var getDeviceParameterInfo, messageId, deviceParameterInfo;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!deviceAddress) {
                        return [2 /*return*/, null];
                    }
                    if (deviceParameterInfoMap.has(deviceAddress)) {
                        return [2 /*return*/, deviceParameterInfoMap.get(deviceAddress)]; // retrieve from cache
                    }
                    getDeviceParameterInfo = { deviceAddress: deviceAddress };
                    messageId = uuid_1.v4();
                    motionMasterClient.sendRequest({ getDeviceParameterInfo: getDeviceParameterInfo }, messageId);
                    return [4 /*yield*/, motionMasterClient.filterMotionMasterMessageById$(messageId).pipe(operators_1.first(), operators_1.map(function (message) { return message && message.status ? message.status.deviceParameterInfo : null; })).toPromise()];
                case 1:
                    deviceParameterInfo = _a.sent();
                    deviceParameterInfoMap.set(deviceAddress, deviceParameterInfo); // cache
                    return [2 /*return*/, deviceParameterInfo];
            }
        });
    });
}
function paramToIndexSubindex(paramValue) {
    var _a = paramValue.split(':'), indexStr = _a[0], subindexStr = _a[1];
    var index = parseInt(indexStr, 16);
    var subindex = parseInt(subindexStr, 10) || 0;
    return { index: index, subindex: subindex };
}
function paramToIndexSubIndexValue(paramValue, deviceParameterInfo) {
    var _a = paramValue.split('='), param = _a[0], value = _a[1];
    var _b = paramToIndexSubindex(param), index = _b.index, subindex = _b.subindex;
    var parameterValue = { index: index, subindex: subindex };
    if (deviceParameterInfo) {
        if (deviceParameterInfo.parameters) {
            var parameter = deviceParameterInfo.parameters.find(function (p) { return p.index === index && p.subindex === subindex; });
            if (parameter) {
                var VT = motion_master_proto_1.motionmaster.MotionMasterMessage.Status.DeviceParameterInfo.Parameter.ValueType;
                switch (parameter.valueType) {
                    case VT.UNSPECIFIED:
                    case VT.INTEGER8:
                    case VT.INTEGER16:
                    case VT.INTEGER32: {
                        parameterValue.intValue = parseInt(value, 10);
                        break;
                    }
                    case VT.BOOLEAN:
                    case VT.UNSIGNED8:
                    case VT.UNSIGNED16:
                    case VT.UNSIGNED32: {
                        parameterValue.uintValue = parseInt(value, 10);
                        break;
                    }
                    case VT.REAL32: {
                        parameterValue.floatValue = parseFloat(value);
                        break;
                    }
                    case VT.VISIBLE_STRING:
                    case VT.OCTET_STRING:
                    case VT.UNICODE_STRING:
                    case VT.TIME_OF_DAY: {
                        parameterValue.stringValue = value;
                        break;
                    }
                }
            }
        }
    }
    return parameterValue;
}
function getCommandDeviceAddressAsync(cmd) {
    return __awaiter(this, void 0, void 0, function () {
        var device;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!cmd.deviceAddress) return [3 /*break*/, 1];
                    return [2 /*return*/, cmd.deviceAddress];
                case 1:
                    if (!Number.isInteger(cmd.devicePosition)) return [3 /*break*/, 3];
                    return [4 /*yield*/, motionMasterClient.getDeviceAtPosition$(cmd.devicePosition).toPromise()];
                case 2:
                    device = _a.sent();
                    if (device) {
                        return [2 /*return*/, device.deviceAddress];
                    }
                    else {
                        throw new Error("There is no device at position " + cmd.devicePosition);
                    }
                    return [3 /*break*/, 4];
                case 3: return [2 /*return*/, null];
                case 4: return [2 /*return*/];
            }
        });
    });
}
function exitOnMessageReceived(messageId, due, exitOnSuccessCode) {
    if (due === void 0) { due = 10000; }
    motionMasterClient.filterMotionMasterMessageById$(messageId).pipe(operators_1.first(function (message) {
        if (exitOnSuccessCode === undefined) {
            return true;
        }
        else {
            if (message && message.status) {
                var key = Object.keys(message.status)[0];
                var status_1 = message.status[key];
                if (status_1 && (status_1.success.code === exitOnSuccessCode || status_1.error)) {
                    return true;
                }
            }
            return false;
        }
    }), operators_1.timeout(due)).subscribe({
        next: function () {
            debug("Exit on message received " + messageId);
            process.exit(0);
        },
        error: function (err) {
            console.error(err.name + ": Status message " + messageId + " not received for more than " + due + " ms.");
            process.exit(-1);
        },
    });
}
function printOnMessageReceived(messageId, outputFormat) {
    if (outputFormat === void 0) { outputFormat = 'inspect'; }
    motionMasterClient.filterMotionMasterMessageById$(messageId).subscribe(function (msg) {
        var timestamp = Date.now();
        var message = msg.toJSON();
        var outputObj = { timestamp: timestamp, message: message };
        switch (outputFormat) {
            case 'json':
                console.log(JSON.stringify(outputObj));
                break;
            case 'yaml':
                console.log(yaml_1.default.stringify(outputObj));
                break;
            default:
                console.log(util_1.default.inspect(outputObj, inspectOptions));
        }
    });
}
function parseOptionValueAsInt(value) {
    return parseInt(value, 10);
}
//# sourceMappingURL=cli.js.map